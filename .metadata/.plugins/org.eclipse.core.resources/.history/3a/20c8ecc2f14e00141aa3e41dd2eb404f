package Algorithms;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArrayList;




public class Density implements Algorithm {

	public Deque<Double> densities;
	public double max;
	
	public Density() {
		super();
		this.densities = new ArrayDeque<Double>();
		this.max = 0;
	}

	public Deque<Double> getDensities() {
		return densities;
	}

	public void setDensities(Deque<Double> densities) {
		this.densities = densities;
	}

	public double getMax() {
		return max;
	}
		
	public void setMax(double max) {
		this.max = max;
	}
	
	public int getSize(){
		return densities.size();
	}
	
	public int distance(int reference, int val) {
		int distance = Math.abs(val-reference);
		return distance;

	}

	/**
	 * Density.
	 *
	 * @param data the data
	 * @param p reference point to which is calculated the density
	 * @param x the point to which we are calculating the density
	 */
	public void calculate(Deque<Integer> data){
		double density = 0;
		double sum = 0;
		int p = new DescriptiveStats(data).getMean();
		CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<Integer>(data);
		for(int i: list){
			for(int j: list){
				if(i!=j)
				sum+= Math.abs(distance(j,p) - distance(i,p));
			}
			density=(list.size()-1)/sum;
			if(density>max)max=density;
			densities.add(density);
		}
//		if(sum!=0){
//			int k = data.size()-1;
//			density=k/sum;
//			if (density>max){
//				max = density;
//			}
//			if(densities.isEmpty()){
//				densities.offerFirst(density);
//			}
//			else{
//				densities.offerLast(density);
//			}
//		}
//		else{
//			if(densities.isEmpty()){
//				densities.offerFirst(0.0);
//			}
//			else{
//				densities.offerLast(0.0);
//			}	
//		}
	}
	
	
	
	public void calcMax(){
		for (double d:densities){
			if(d>max){
				max=d;
			}
		}
	}
	
	//The bigger ros is, the likelier is to be an outlier
	public double probOutlier() {
		if(!densities.contains(max)){
			calcMax();
		}
		double ros = 0;
		if(max!=0){
			ros = 1 - (densities.getLast()/max);
		}
		//We do the following, to avoid to detect an outlier when the most of the visits are 0;
		if(ros==1 && max<2){ 
			ros=0;
		}
		return ros;
	}

	@Override
	public void deleteFirst() {
		densities.removeFirst();
	}

	@Override
	public String toString(){
		return this.densities.toString();	
	}



}
