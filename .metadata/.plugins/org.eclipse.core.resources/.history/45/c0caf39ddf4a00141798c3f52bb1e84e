import java.io.File;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;



public class WriteRead {

	public Info info;
	public boolean controlRead;
	public boolean controlWrite;
	//public static boolean keys = false;
	private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(true);
	private final Lock r = rwl.readLock();
	private final Lock w = rwl.writeLock();

	public WriteRead(Info info){
		this.info=info;
		controlRead=true;
		controlWrite=true;
	}
	
	

	public Info getInfo() {
		return info;
	}



	public boolean isControlRead() {
		return controlRead;
	}



	public boolean isControlWrite() {
		return controlWrite;
	}

	public void write(List<File> files, FileManager writer) throws InterruptedException{
		for (File file: files){
			w.tryLock();
			writer.parse(file, info);
			System.out.println(info.getInfo().get("de Haiti"));
			while(info.getSizeDeque()>10){
				w.unlock();
			}
		}
		controlWrite=false; //When all the files have been parsed I want this thread to end.
	}

	public void compute(String key) throws InterruptedException{
		r.lock();
		info.getInfo().get(key).removeFirst(); //I take out the first element, expecting that the other thread fills with a new value the deque
		r.unlock();
		if(info.isEmptyDeque(key)){
			controlRead=false;
		}
	}


	public static void main(String[] args){
		final WriteRead wr=new WriteRead(new Info());
		final FileManager fm = new FileManager();
		final String rootDirectory = "/Users/alvaro/Documents/TUGraz/Master Thesis/TrainingSet/";
		Thread writer = new Thread(){
			public void run(){
				while(wr.isControlRead()){
					try {
						wr.write(fm.listDirectories(rootDirectory),fm);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		};
		writer.start();
		Thread reader = new Thread(){
			public void run(){
				while(wr.isControlWrite()){
					try {
						wr.compute("de Haiti");
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		};
		reader.start();
		

	}
}
